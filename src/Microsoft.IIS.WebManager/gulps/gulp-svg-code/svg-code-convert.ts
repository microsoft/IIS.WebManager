declare function escape(data: string): string;
declare function unescape(data: string): string;

export class SvgCodeConverter {
    private static openContentTs =
`/* tslint:disable */
/**
 * @file Source code generated by gulp-svg-code.
 * @version 1.0
 */
export module Svg {
    'use strict'
`;
    private static closeContentTs =
`}
`;
    private static openContentCss =
`/**
 * @file Source code generated by gulp-svg-code.
 * @version 1.0
 */
`;
    private outputCss: string[] = [];
    private outputTs: string[] = [];

    public get contentCss(): string {
        return this.outputCss.join('');
    }

    public get contentTs(): string {
        return this.outputTs.join('');
    }

    public contentReset(): void {
        this.outputCss = [];
        this.outputTs = [];
    }

    public generate(collection: { [index: string]: any }, pathPrefix: string): void {
        let root = this.createStructure(collection, pathPrefix);
        this.outputCss.push(SvgCodeConverter.openContentCss);
        this.outputTs.push(SvgCodeConverter.openContentTs);
        this.addData(root, []);
        this.outputTs.push(SvgCodeConverter.closeContentTs);
    }

    private addData(current: any, segments: string[]): void {
        const ignores = [ '<?xml', '<!-- Generator:', '<!DOCTYPE' ];
        let nested: any[] = [];
        let keys = Object.keys(current);
        for (let key of keys) {
            let content = current[key];
            segments.push(key);

            if (typeof content === 'object') {
                let segs = segments.slice(0);
                nested.push({ content, segs });
            } else if (typeof content === 'string') {
                let cssName = '.svg-' + segments.join('--');
                this.outputCss.push(cssName + ' {\r\n');
                this.outputCss.push(this.indent(1) + 'background-image: url("data:image/svg+xml;');

                this.outputTs.push(this.indent(segments.length) + 'export const ' + key + ' = \'');

                let lines = content.split('\r');
                let svg = '';
                lines.forEach((value, index, array) => {
                    value = value.replace('\n', '');
                    if (value && value.length > 1) {
                        let skip = false;
                        for (let item of ignores) {
                            if (value.indexOf(item) >= 0) {
                                skip = true;
                                break;
                            }
                        }

                        if (!skip) {
                            svg += value;
                            // this.outputCss.push(value);
                            this.outputTs.push(value);
                        }
                    }
                });

                svg = this.replaceAll(svg, '"', '\'');
                svg = this.replaceAll(svg, '%', '%25');
                svg = this.replaceAll(svg, '#', '%23');       
                svg = this.replaceAll(svg, '{', '%7B');
                svg = this.replaceAll(svg, '}', '%7D');         
                svg = this.replaceAll(svg, '<', '%3C');
                svg = this.replaceAll(svg, '>', '%3E');
                this.outputCss.push('charset=utf8,' + svg);

                this.outputCss.push('");\r\n');
                this.outputCss.push('}\r\n');
                this.outputCss.push('\r\n');

                this.outputTs.push('\';\r\n');
            }

            segments.pop();
        }

        for (let index = 0; index < nested.length; index++) {
            let { content, segs } = nested[index];
            this.outputTs.push(this.indent(segs.length) + 'export module ' + segs[segs.length - 1] + ' {\r\n');
            this.addData(nested[index].content, nested[index].segs);
            this.outputTs.push(this.indent(segs.length) + '}\r\n');
        }
    }

    private createStructure(collection: { [index: string]: any }, pathPrefix: string): any {
        let root = {};
        let keys = Object.keys(collection).sort((left, right) => left.toLowerCase().localeCompare(right.toLowerCase()));
        for (let key of keys) {
            let shortName = key.substr(0, key.length - '.svg'.length);
            shortName = this.replaceAll(shortName.substr(pathPrefix.length + 1), '-', '_').toLowerCase();
            let segments = shortName.split('\\');
            let current = root;
            for (let index = 0; index < segments.length - 1; index++) {
                let segment = segments[index];
                if (current.hasOwnProperty(segment)) {
                    current = current[segment];
                } else {
                    current[segment] = {};
                    current = current[segment];
                }
            }

            current[segments[segments.length - 1]] = collection[key];
        }

        return root;
    }

    private regexEscape(str: string): string {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    }

    private replaceAll(input: string, searchValue: string, replaceValue: string): string {
        return input.replace(new RegExp(this.regexEscape(searchValue), 'g'), replaceValue);
    }

    private indent(count: number): string {
        let pad = '';
        for (let i = 0; i < count; i++) {
            pad += '    ';
        }

        return pad;
    }
}
